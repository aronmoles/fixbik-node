[["/Users/cuatroochenta/MagicShopper/magicshopper-node/src/microk/docs/openapi/index.test.ts",{"fileContent":"import OpenApi from './index';\n\ndescribe('OpenApi', () => {\n    it('should create a valid auth token', async () => {\n        const openApi = new OpenApi({\n            baseDir: `${__dirname}/examples`,\n            filesPattern: './*.ts',\n            info: {\n                title: 'Test',\n                version: '1.0.0',\n                description: 'Public API',\n                license: {\n                    name: 'MIT',\n                },\n            },\n            components: {\n                securitySchemes: {\n                    jwt: {\n                        type: 'http',\n                        scheme: 'bearer',\n                        bearerFormat: 'JWT',\n                    },\n                },\n            },\n        })\n\n        const openApiDoc = openApi.generateDocs();\n\n        expect(openApiDoc).toEqual({\n            openapi: '3.0.0',\n            info: {\n                title: 'Test',\n                version: '1.0.0',\n                description: 'Public API',\n                license: {\n                    name: 'MIT',\n                },\n            },\n            paths: {\n                '/notification': {\n                    post: {\n                        operationId: 'addJob',\n                        tags: [\n                            'jobs',\n                        ],\n                        summary: 'Creates a new notification.',\n                        description: '',\n                        security: [\n                            {\n                                jwt: [],\n                            },\n                        ],\n                        requestBody: {\n                            description: 'Notification object to create',\n                            required: true,\n                            content: {\n                                'application/json': {\n                                    schema: {\n                                        $ref: '#/components/schemas/Notification',\n                                    },\n                                },\n                            },\n                        },\n                        responses: {\n                            201: {\n                                description: 'Successful operation. The notification has been created on the server.',\n                                content: {\n                                    'application/json': {\n                                        schema: {\n                                            $ref: '#/components/schemas/Notification',\n                                        },\n                                    },\n                                },\n                            },\n                            400: {\n                                description: 'Bad Request',\n                                content: {\n                                    'application/json': {\n                                        schema: {\n                                            $ref: '#/components/schemas/Error',\n                                        },\n                                    },\n                                },\n                            },\n                        },\n                    },\n                },\n            },\n            components: {\n                securitySchemes: {\n                    jwt: {\n                        type: 'http',\n                        scheme: 'bearer',\n                        bearerFormat: 'JWT',\n                    },\n                },\n                schemas: {\n                    Error: {\n                        type: 'object',\n                        properties: {\n                            message: {\n                                type: 'string',\n                            },\n                            code: {\n                                type: 'integer',\n                                example: 404,\n                            },\n                        },\n                    },\n                    Notification: {\n                        type: 'object',\n                        required: [\n                            'serviceUrl',\n                        ],\n                        properties: {\n                            serviceUrl: {\n                                type: 'string',\n                            },\n                            authenticationHeader: {\n                                type: 'string',\n                            },\n                            certificateSubject: {\n                                type: 'string',\n                            },\n                            parameters: {\n                                type: 'string',\n                            },\n                        },\n                    },\n                },\n            },\n        })\n    });\n});\n","resolvedModuleNames":["/Users/cuatroochenta/MagicShopper/magicshopper-node/src/microk/docs/openapi/index.ts"]}],["/Users/cuatroochenta/MagicShopper/magicshopper-node/src/microk/docs/openapi/index.ts",{"fileContent":"import doctrine from 'doctrine';\nimport fs from 'fs';\nimport glob from 'glob';\nimport mergeWith from 'lodash.mergewith';\nimport { OpenAPIObject } from 'openapi3-ts';\nimport {\n    ComponentsObject,\n    ExternalDocumentationObject,\n    InfoObject,\n    PathsObject,\n    SecurityRequirementObject,\n    ServerObject,\n    TagObject,\n} from 'openapi3-ts/src/model/OpenApi';\nimport path from 'path';\nimport YAML from 'yaml';\n\nexport type OpenApiConfig = {\n    baseDir: string,\n    filesPattern: string,\n\n    info: InfoObject;\n    servers?: ServerObject[];\n    paths?: PathsObject;\n    components?: ComponentsObject;\n    security?: SecurityRequirementObject[];\n    tags?: TagObject[];\n    externalDocs?: ExternalDocumentationObject;\n}\n\nexport default class OpenApi {\n    private static DEFAULT_EXCLUDED_FOLDER = 'node_modules';\n    private static DEFAULT_GLOB_OPTIONS = { ignore: '**/node_modules/**' };\n    // eslint-disable-next-line prefer-named-capture-group\n    private static COMMENTS_PATTERN = /((\\/\\*\\*+[\\s\\S]*?\\*\\/)|(\\/\\*+.*\\*\\/)|^\\/\\/.*?[\\r\\n])[\\r\\n]*/gm;\n    private static BREAK_LINE = /\\n/g;\n\n    constructor(\n        private readonly config: OpenApiConfig,\n    ) {\n    }\n\n    private globFilesMatches = (\n        baseDir: string,\n        filesPattern: string,\n        excludedFolder: string = OpenApi.DEFAULT_EXCLUDED_FOLDER,\n    ) => {\n        try {\n            const files = glob.sync(path.resolve(baseDir, filesPattern), OpenApi.DEFAULT_GLOB_OPTIONS);\n            return files.filter((file) => !file.includes(excludedFolder));\n        } catch (error) {\n            throw new Error('Error Glob Files');\n        }\n    }\n\n    private readFile(filePath: string): string {\n        return fs.readFileSync(filePath).toString();\n    }\n\n    private readFiles(files: string[]): string[] {\n        if (!files || !Array.isArray(files)) {\n            return [];\n        }\n        return files.map((file) => this.readFile(file));\n    }\n\n\n    private getComments = (text) => {\n        const comments = text.match(OpenApi.COMMENTS_PATTERN);\n        if (comments) {\n            const filterComments = comments.filter((comment) => comment.match(OpenApi.BREAK_LINE));\n            return filterComments.map((comment) => comment.trim());\n        }\n        return [];\n    };\n\n    private getOnlyComments(fileContents: string[] = []) {\n        if (!Array.isArray(fileContents)) {\n            return [];\n        }\n        const comments = fileContents.map((comment) => {\n            const trimedComments = comment.trim();\n            return this.getComments(trimedComments);\n        });\n        return [].concat(...comments).filter((comment) => (comment[0] === '/' && comment[1] !== '/'));\n    }\n\n    private jsdocInfo(comments): any[] {\n        if (!comments || !Array.isArray(comments)) {\n            return [];\n        }\n        return comments.map((comment) => {\n            const jsDocComment = doctrine.parse(comment, { unwrap: true });\n            return jsDocComment;\n        });\n    }\n\n    private parseYamlComments(jsDoc: any[]) {\n        const yamlComments = []\n        for (const doc of jsDoc) {\n            for (const tag of doc.tags) {\n                if (tag.title === 'openapi') {\n                    yamlComments.push(tag.description)\n                }\n            }\n        }\n        return yamlComments;\n    }\n\n    private parseJsonCommentsFromYaml(yamlComments): object[] {\n        const jsons = []\n        for (const doc of yamlComments) {\n            const parsed = YAML.parseDocument(doc);\n\n            const anchors = parsed.anchors.getNames();\n            if (anchors.length) {\n                throw new Error('Error parsing YAML comments');\n            } else if (parsed.errors && parsed.errors.length) {\n                throw new Error('Error parsing YAML comments');\n            } else {\n                jsons.push(parsed.toJSON());\n            }\n        }\n        return jsons;\n    }\n\n    private mergeDeep(first, second) {\n        return mergeWith({}, first, second, (x, y) => (y === null ? x : undefined));\n    }\n\n    private removeEmptyKeys(obj) {\n        if (!obj) {\n            return {};\n        }\n        Object.keys(obj).forEach((key) => {\n            if (obj[key] === undefined) {\n                delete obj[key];\n            }\n        });\n        return obj;\n    }\n\n    private buildOpenApiObject(jsonComments: object[]): OpenAPIObject {\n        const openApi: OpenAPIObject = this.removeEmptyKeys({\n            openapi: '3.0.0',\n            info: this.config.info,\n            servers: this.config.servers,\n            paths: this.config.paths || {},\n            components: {\n                ...this.config.components,\n                schemas: this.config.components.schemas || {},\n            },\n            security: this.config.security,\n            tags: this.config.tags,\n            externalDocs: this.config.externalDocs,\n        });\n\n        for (const jsonComment of jsonComments) {\n            for (const key of Object.keys(jsonComment)) {\n                if (key.startsWith('/')) {\n                    openApi.paths[key] = this.mergeDeep(openApi.paths[key], jsonComment[key]);\n                } else {\n                    openApi.components.schemas[key] = jsonComment[key];\n                }\n            }\n        }\n\n        return openApi;\n    }\n\n    generateDocs(): OpenAPIObject {\n        const files = this.globFilesMatches(this.config.baseDir, this.config.filesPattern);\n        const fileContents = this.readFiles(files);\n        const comments = this.getOnlyComments(fileContents);\n        const jsDocInfo = this.jsdocInfo(comments)\n        const yamlComments = this.parseYamlComments(jsDocInfo)\n        const jsonComments = this.parseJsonCommentsFromYaml(yamlComments)\n        return this.buildOpenApiObject(jsonComments);\n    }\n}\n","resolvedModuleNames":[]}]]